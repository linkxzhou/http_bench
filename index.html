<!DOCTYPE html>
<html :lang="currentLanguage" style="height: 100%">
<head>
    <!-- Meta tags for responsive design -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
    <!-- External dependencies -->
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css">
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js"></script>
    <script src="https://unpkg.com/element-ui/lib/index.js"></script>
    
    <!-- Custom Styles -->
    <style>
        :root {
            --primary: #667eea;
            --gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --danger: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --shadow: 0 10px 40px rgba(0,0,0,0.15);
            --radius: 16px;
            --text-main: #333;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--gradient);
            min-height: 100vh;
            padding: 20px;
            color: var(--text-main);
        }

        .main-container { max-width: 1400px; margin: 0 auto; }

        /* Headers */
        .page-header {
            text-align: center; color: white; margin-bottom: 30px;
            animation: fadeInDown 0.6s ease-out;
        }
        .page-header h2 { font-size: 2rem; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.2); }
        .page-header p { opacity: 0.9; font-size: 1.1rem; }

        /* Cards & Panels */
        .chart-card, .control-panel, .stat-card {
            background: white;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 20px;
            margin-bottom: 30px;
            animation: fadeInUp 0.6s ease-out;
        }
        .control-panel { padding: 30px; }
        
        .chart-card-header, .control-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #f0f0f0;
        }
        .chart-card-title, .control-title { font-size: 1.3rem; font-weight: 600; }

        /* Buttons */
        .button-group { display: flex; gap: 15px; margin-bottom: 25px; }
        .button-group .el-button {
            flex: 1; height: 50px; font-size: 16px; border-radius: 10px; border: none;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        .button-group .el-button:hover { transform: translateY(-2px); }
        .button-group .el-button--primary { background: var(--gradient); }
        .button-group .el-button--primary:hover { box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4); }
        .button-group .el-button--danger { background: var(--danger); }
        .button-group .el-button--danger:hover:not(:disabled) { box-shadow: 0 8px 20px rgba(245, 87, 108, 0.4); }

        /* Forms */
        .form-section { margin-bottom: 25px; }
        .section-title {
            font-size: 1.1rem; font-weight: 600; color: #555;
            margin-bottom: 15px; padding-left: 10px; border-left: 4px solid var(--primary);
        }
        .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; }
        .form-item-full { grid-column: 1 / -1; }
        .el-input, .el-select { margin: 0 !important; }
        
        .el-input__inner, .el-textarea__inner {
            border-radius: 8px; border: 2px solid #e8e8e8; transition: all 0.3s;
        }
        .el-input__inner:focus, .el-textarea__inner:focus {
            border-color: var(--primary); box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .el-input-group__prepend {
            background: var(--gradient); color: white; border: none; font-weight: 600; border-radius: 8px 0 0 8px;
        }
        .language-selector .el-input__inner {
            background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.3); color: white; font-weight: 600;
        }

        .charts-row { display: grid; grid-template-columns: 1fr 1fr; gap: 25px; margin-bottom: 30px; animation-fill-mode: both; }

        /* Animations */
        @keyframes fadeInDown { from { opacity: 0; transform: translateY(-30px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(30px); } to { opacity: 1; transform: translateY(0); } }

        /* Responsive */
        @media (max-width: 992px) { .charts-row { grid-template-columns: 1fr; } }
        @media (max-width: 768px) {
            .page-header h2 { font-size: 1.5rem; }
            .button-group, .form-grid { flex-direction: column; }
            .control-panel { padding: 20px; }
        }
    </style>
    
    <script type="text/javascript">
        // i18n configuration for multilingual support
        const translations = {
            'zh-CN': {
                title: 'ğŸš€ HTTP å‹åŠ›æµ‹è¯•å·¥å…·',
                subtitle: 'ä¸“ä¸šçš„HTTP/1/2/3æ€§èƒ½æµ‹è¯•å·¥å…·',
                start: 'å¼€å§‹å‹æµ‹',
                stop: 'åœæ­¢å‹æµ‹',
                chart: {
                    title: 'ğŸ“Š å®æ—¶æ€§èƒ½æŒ‡æ ‡',
                    qps: 'QPS',
                    statusCode: 'çŠ¶æ€ç ',
                    latency: 'ğŸ“Š å“åº”è€—æ—¶åˆ†å¸ƒ',
                    errorDist: 'âš ï¸ é”™è¯¯åˆ†å¸ƒ'
                },
                stats: {
                    avg: 'å¹³å‡è€—æ—¶',
                    rps: 'å¹³å‡ QPS',
                    fastest: 'æœ€å¿«è€—æ—¶',
                    slowest: 'æœ€æ…¢è€—æ—¶',
                    errors: 'é”™è¯¯æ€»æ•°'
                },
                section: {
                    testConfig: 'âš™ï¸ æµ‹è¯•é…ç½®',
                    requestConfig: 'ğŸŒ è¯·æ±‚é…ç½®',
                    stressParams: 'âš¡ å‹æµ‹å‚æ•°',
                    advancedSettings: 'ğŸ”§ é«˜çº§è®¾ç½®'
                },
                metrics: {
                    duration: 'é‡‡é›†é—´éš”ï¼ˆæ¯«ç§’ï¼‰',
                    durationPlaceholder: 'ç›‘æ§æ•°æ®åˆ·æ–°é—´éš”ï¼Œé»˜è®¤2000ms'
                },
                request: {
                    url: 'è¯·æ±‚åœ°å€',
                    urlPlaceholder: 'è¯·è¾“å…¥å‹æµ‹ç›®æ ‡URL',
                    method: 'è¯·æ±‚æ–¹æ³•',
                    methodPlaceholder: 'é€‰æ‹©è¯·æ±‚æ–¹æ³•',
                    body: 'è¯·æ±‚ä½“',
                    bodyPlaceholder: 'è¯·è¾“å…¥è¯·æ±‚ä½“å†…å®¹',
                    bodyType: 'è¯·æ±‚ä½“ç±»å‹',
                    bodyTypePlaceholder: 'ç©ºæˆ–hexï¼Œé»˜è®¤ç©º',
                    type: 'åè®®ç±»å‹',
                    typePlaceholder: 'http1, http2, ws, wssï¼Œé»˜è®¤http1'
                },
                stress: {
                    total: 'æ€»è¯·æ±‚æ•°',
                    totalPlaceholder: '0 = æ— é™åˆ¶',
                    concurrent: 'å¹¶å‘æ•°',
                    concurrentPlaceholder: '1-10000',
                    duration: 'æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰',
                    durationPlaceholder: 'æ¯«ç§’',
                    timeout: 'è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰',
                    timeoutPlaceholder: 'æ¯«ç§’',
                    qps: 'QPSé™åˆ¶',
                    qpsPlaceholder: '0 = æ— é™åˆ¶',
                    worker: 'Worker API',
                    workerPlaceholder: '/api æˆ–è‡ªå®šä¹‰ç«¯ç‚¹'
                },
                advanced: {
                    compression: 'ç¦ç”¨å‹ç¼©',
                    keepalive: 'ç¦ç”¨Keep-Alive',
                    auth: 'è®¤è¯ä¿¡æ¯',
                    username: 'ç”¨æˆ·å',
                    password: 'å¯†ç '
                },
                message: {
                    start: 'å‹æµ‹å·²å¼€å§‹',
                    stop: 'å‹æµ‹å·²åœæ­¢',
                    error: 'å‹æµ‹é”™è¯¯',
                    success: 'æ“ä½œæˆåŠŸ',
                    warning: 'è­¦å‘Š',
                    info: 'æç¤º'
                },
                validation: {
                    urlRequired: 'è¯·è¾“å…¥è¯·æ±‚åœ°å€',
                    urlInvalid: 'è¯·è¾“å…¥æœ‰æ•ˆçš„URL',
                    concurrentInvalid: 'å¹¶å‘æ•°å¿…é¡»åœ¨1-10000ä¹‹é—´',
                    durationInvalid: 'æŒç»­æ—¶é—´å¿…é¡»å¤§äº0'
                }
            },
            'en-US': {
                title: 'ğŸš€ HTTP Benchmark Tool',
                subtitle: 'Professional HTTP Performance Testing Tool',
                start: 'Start Test',
                stop: 'Stop Test',
                chart: {
                    title: 'ğŸ“Š Real-time Performance Metrics',
                    qps: 'QPS',
                    statusCode: 'Status Code',
                    latency: 'ğŸ“Š Latency Distribution',
                    errorDist: 'âš ï¸ Error Distribution'
                },
                stats: {
                    avg: 'Average Latency',
                    rps: 'Average RPS',
                    fastest: 'Fastest Request',
                    slowest: 'Slowest Request',
                    errors: 'Total Errors'
                },
                section: {
                    testConfig: 'âš™ï¸ Test Configuration',
                    requestConfig: 'ğŸŒ Request Configuration',
                    stressParams: 'âš¡ Stress Test Parameters',
                    advancedSettings: 'ğŸ”§ Advanced Settings'
                },
                metrics: {
                    duration: 'Metrics Interval (MS)',
                    durationPlaceholder: 'Metrics refresh interval, default 2000ms'
                },
                request: {
                    url: 'Request URL',
                    urlPlaceholder: 'Enter target URL for stress test',
                    method: 'Request Method',
                    methodPlaceholder: 'Select HTTP method',
                    body: 'Request Body',
                    bodyPlaceholder: 'Enter request body content',
                    bodyType: 'Body Type',
                    bodyTypePlaceholder: 'empty or hex, default empty',
                    type: 'Protocol Type',
                    typePlaceholder: 'http1, http2, ws, wss, default http1'
                },
                stress: {
                    total: 'Total Requests',
                    totalPlaceholder: '0 = unlimited',
                    concurrent: 'Concurrent Connections',
                    concurrentPlaceholder: '1-10000',
                    duration: 'Duration (MS)',
                    durationPlaceholder: 'milliseconds',
                    timeout: 'Timeout (MS)',
                    timeoutPlaceholder: 'milliseconds',
                    qps: 'QPS Limit',
                    qpsPlaceholder: '0 = unlimited',
                    worker: 'Worker API',
                    workerPlaceholder: '/api or custom endpoint'
                },
                advanced: {
                    compression: 'Disable Compression',
                    keepalive: 'Disable Keep-Alive',
                    auth: 'Authentication',
                    username: 'Username',
                    password: 'Password'
                },
                message: {
                    start: 'Benchmark test started',
                    stop: 'Benchmark test stopped',
                    error: 'Benchmark test error',
                    success: 'Operation successful',
                    warning: 'Warning',
                    info: 'Information'
                },
                validation: {
                    urlRequired: 'Please enter request URL',
                    urlInvalid: 'Please enter a valid URL',
                    concurrentInvalid: 'Concurrent connections must be between 1-10000',
                    durationInvalid: 'Duration must be greater than 0'
                }
            }
        };
    </script>
    <title id="page-title">HTTP Benchmark Tool</title>
</head>

<body>
    <!-- Page Header -->
    <div class="page-header">
        <h2 id="page-title">ğŸš€ HTTP Benchmark Tool</h2>
        <p id="page-subtitle">Professional HTTP1/2/3 Performance Testing Tool</p>
    </div>
    
    <div class="main-container" id="app">
        <!-- Chart Card -->
        <div class="chart-card">
            <div class="chart-card-header">
                <div class="chart-card-title" id="chart-title">ğŸ“Š Real-time Performance Metrics</div>
            </div>
            <div id="chart-container" style="height: 400px; width: 100%;"></div>
        </div>

        <!-- Secondary Charts -->
        <div class="charts-row" v-show="hasData" style="display: none;" :style="{ display: hasData ? 'grid' : 'none' }">
            <div class="chart-card">
                <div class="chart-card-header">
                    <div class="chart-card-title">{{translate('chart.latency')}}</div>
                </div>
                <div id="latency-chart" style="height: 350px; width: 100%;"></div>
            </div>
            <div class="chart-card">
                <div class="chart-card-header">
                    <div class="chart-card-title">{{translate('chart.errorDist')}}</div>
                </div>
                <div id="error-chart" style="height: 350px; width: 100%;"></div>
            </div>
        </div>
        
        <!-- Control Panel (Vue App) -->
        <div>
            <div class="control-panel">
                <!-- Language selector -->
                <div style="position: absolute; top: 30px; right: 30px; width: 120px;">
                    <el-select v-model="currentLanguage" @change="changeLanguage" size="small" class="language-selector">
                        <el-option label="ğŸ‡¨ğŸ‡³ ä¸­æ–‡" value="zh-CN"></el-option>
                        <el-option label="ğŸ‡ºğŸ‡¸ English" value="en-US"></el-option>
                    </el-select>
                </div>
                <div class="control-header">
                    <div class="control-title" id="control-title">âš™ï¸ Test Configuration</div>
                </div>
                
                <!-- Control Buttons -->
                <div class="button-group">
                    <el-button type="primary" :loading="isRunning" @click="startTest" icon="el-icon-video-play">
                        {{translate('start')}}
                    </el-button>
                    <el-button type="danger" @click="stopTest" :disabled="!isRunning" icon="el-icon-video-pause">
                        {{translate('stop')}}
                    </el-button>
                </div>
                
                <!-- Request Configuration Section -->
                <div class="form-section">
                    <div class="section-title" id="section-request">ğŸŒ Request Configuration</div>
                    <div class="form-grid">
                        <div class="form-item-full">
                            <el-input :placeholder="translate('request.urlPlaceholder')" v-model="requestUrl">
                                <template slot="prepend">{{translate('request.url')}}</template>
                            </el-input>
                        </div>
                        <el-select v-model="protocolType" :placeholder="translate('request.typePlaceholder')" style="width: 100%;">
                            <template slot="prepend">{{translate('request.type')}}</template>
                            <el-option
                                v-for="protocol in protocolOptions"
                                :key="protocol.value"
                                :label="protocol.label"
                                :value="protocol.value">
                            </el-option>
                        </el-select>
                        <el-select v-model="requestMethod" :placeholder="translate('request.methodPlaceholder')" style="width: 100%;">
                            <template slot="prepend">{{translate('request.method')}}</template>
                            <el-option
                                v-for="method in httpMethods"
                                :key="method.value"
                                :label="method.label"
                                :value="method.value">
                            </el-option>
                        </el-select>
                        <div class="form-item-full">
                            <el-input :placeholder="translate('request.bodyPlaceholder')" v-model="requestBody" type="textarea"
                                :autosize="{ minRows: 3, maxRows: 10}">
                                <template slot="prepend">{{translate('request.body')}}</template>
                            </el-input>
                        </div>
                        <el-input :placeholder="translate('request.bodyTypePlaceholder')" v-model="requestBodyType">
                            <template slot="prepend">{{translate('request.bodyType')}}</template>
                        </el-input>
                    </div>
                </div>
                
                <!-- Stress Test Parameters Section -->
                <div class="form-section">
                    <div class="section-title" id="section-stress">âš¡ Stress Test Parameters</div>
                    <div class="form-grid">
                        <el-input :placeholder="translate('stress.totalPlaceholder')" v-model="totalRequests" type="number">
                            <template slot="prepend">{{translate('stress.total')}}</template>
                        </el-input>
                        <el-input :placeholder="translate('stress.concurrentPlaceholder')" v-model="concurrentConnections" type="number">
                            <template slot="prepend">{{translate('stress.concurrent')}}</template>
                        </el-input>
                        <el-input :placeholder="translate('stress.durationPlaceholder')" v-model="testDuration" type="number">
                            <template slot="prepend">{{translate('stress.duration')}}</template>
                        </el-input>
                        <el-input :placeholder="translate('stress.timeoutPlaceholder')" v-model="requestTimeout" type="number">
                            <template slot="prepend">{{translate('stress.timeout')}}</template>
                        </el-input>
                        <el-input :placeholder="translate('stress.qpsPlaceholder')" v-model="qpsLimit" type="number">
                            <template slot="prepend">{{translate('stress.qps')}}</template>
                        </el-input>
                        <el-input :placeholder="translate('metrics.durationPlaceholder')" v-model="metricsInterval" type="number">
                            <template slot="prepend">{{translate('metrics.duration')}}</template>
                        </el-input>
                    </div>
                </div>
                
                <!-- Advanced Settings Section -->
                <div class="form-section">
                    <div class="section-title" id="section-advanced">ğŸ”§ Advanced Settings</div>
                    <div class="form-grid">
                        <div class="form-item-full">
                            <el-input :placeholder="translate('stress.workerPlaceholder')" v-model="workerApiEndpoint">
                                <template slot="prepend">{{translate('stress.worker')}}</template>
                            </el-input>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script type="text/javascript">
        // Date formatting utility
        Date.prototype.format = function (fmt) {
            const formatOptions = {
                "M+": this.getMonth() + 1,
                "d+": this.getDate(),
                "h+": this.getHours(),
                "m+": this.getMinutes(),
                "s+": this.getSeconds(),
                "q+": Math.floor((this.getMonth() + 3) / 3),
                "S": this.getMilliseconds()
            };
            
            if (/(y+)/.test(fmt)) {
                fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
            }
            
            for (let key in formatOptions) {
                if (new RegExp("(" + key + ")").test(fmt)) {
                    fmt = fmt.replace(RegExp.$1, 
                        (RegExp.$1.length === 1) ? 
                            (formatOptions[key]) : 
                            (("00" + formatOptions[key]).substr(("" + formatOptions[key]).length)));
                }
            }
            return fmt;
        };

        // Constants
        const API_COMMANDS = {
            START: 0,
            STOP: 1,
            GET_METRICS: 2
        };
        const DEFAULT_API_PATH = "/api";
        const CONTENT_TYPE_JSON = { 'Content-Type': 'application/json;charset=utf-8' };
        const DEFAULT_METRICS_INTERVAL = 2000;
        const TIME_FORMAT = "hh:mm:ss";

        // Helper functions
        const formatDuration = ns => {
            if (!ns) return '0ms';
            if (ns < 1e6) return (ns / 1e3).toFixed(2) + 'Âµs';
            if (ns < 1e9) return (ns / 1e6).toFixed(2) + 'ms';
            return (ns / 1e9).toFixed(2) + 's';
        };

        const debounce = (fn, delay) => {
            let timer = null;
            return function() {
                clearTimeout(timer);
                timer = setTimeout(() => fn.apply(this, arguments), delay);
            };
        };

        // Vue application instance
        new Vue({
            el: '#app',
            data: {
                // Application state
                currentLanguage: 'zh-CN',
                metricsInterval: DEFAULT_METRICS_INTERVAL,
                requestMethod: "GET",
                requestBody: "",
                requestBodyType: "",
                protocolType: "http1",
                protocolOptions: [
                    { value: 'http1', label: 'HTTP<S>/1.1' },
                    { value: 'http2', label: 'HTTP<S>/2' },
                    { value: 'http3', label: 'HTTP<S>/3' },
                    { value: 'ws', label: 'WebSocket(ws://)' },
                    { value: 'wss', label: 'WebSocket Secure(wss://)' }
                ],
                httpMethods: [
                    { value: 'OPTIONS', label: 'OPTIONS' },
                    { value: 'GET', label: 'GET' },
                    { value: 'HEAD', label: 'HEAD' },
                    { value: 'POST', label: 'POST' },
                    { value: 'PUT', label: 'PUT' },
                    { value: 'DELETE', label: 'DELETE' },
                    { value: 'TRACE', label: 'TRACE' },
                    { value: 'CONNECT', label: 'CONNECT' }
                ],
                totalRequests: 0,
                concurrentConnections: 1,
                testDuration: 10000,
                requestTimeout: 3000,
                qpsLimit: 0,
                disableCompression: false,
                disableKeepalives: false,
                authUsername: "",
                authPassword: "",
                requestUrl: "http://httpbin.org/get",
                workerApiEndpoint: "",
                isRunning: false,
                metricsTimer: undefined,
                hasData: false,
                stats: { average: '0ms', rps: 0, fastest: '0ms', slowest: '0ms', errTotal: 0 },
                charts: {},
                monitor: {
                    timeLabels: [],
                    qpsData: [],
                    total: 0,
                    statusCodes: {},
                    prevStatusCounts: {}
                }
            },
            methods: {
                // i18n translation method
                translate(key) {
                    const keyParts = key.split('.');
                    let translation = translations[this.currentLanguage];
                    
                    for (const part of keyParts) {
                        translation = translation[part];
                        if (!translation) break;
                    }
                    
                    return translation || key;
                },
                
                // Switch language
                changeLanguage(language) {
                    this.currentLanguage = language;
                    localStorage.setItem('preferred-language', language);
                    
                    // Update all static text elements
                    this.updateStaticTexts();
                    document.documentElement.setAttribute('lang', language);
                },
                
                // Update static text elements
                updateStaticTexts() {
                    document.getElementById('page-title').innerText = this.translate('title');
                    document.getElementById('page-subtitle').innerText = this.translate('subtitle');
                    document.getElementById('chart-title').innerText = this.translate('chart.title');
                    document.getElementById('control-title').innerText = this.translate('section.testConfig');
                    document.getElementById('section-request').innerText = this.translate('section.requestConfig');
                    document.getElementById('section-stress').innerText = this.translate('section.stressParams');
                    document.getElementById('section-advanced').innerText = this.translate('section.advancedSettings');
                },
                
                // Show message
                showMessage(messageKey, type = 'success', duration = 2000) {
                    this.$message({
                        showClose: true,
                        message: this.translate(`${messageKey}`) || messageKey,
                        type: type,
                        duration: duration,
                    });
                },
                
                // Start stress test
                startTest() {
                    this.sequenceId = Math.floor(Math.random() * 1000000) + 1;
                    // Build request data
                    const requestData = this.buildRequestData(API_COMMANDS.START);
                    const apiEndpoint = this.getWorkerApiEndpoint();
                    
                    this.showMessage('start');
                    // Send start stress test request
                    fetch(apiEndpoint, {
                        method: 'POST',
                        headers: CONTENT_TYPE_JSON,
                        body: JSON.stringify(requestData)
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.err_code !== 0) {
                            this.isRunning = false;
                            this.metricsTimer && clearInterval(this.metricsTimer);
                            this.showMessage(data.err_msg, 'error', 5000);
                            return;
                        }
                    })
                    .catch(error => {
                        this.showMessage(error.message, 'error', 5000);
                        this.isRunning = false;
                    });
                    
                    // Setup monitoring
                    this.setupMetricsMonitoring(requestData, apiEndpoint);
                },
                
                // Build request data
                buildRequestData(command) {
                    return {
                        cmd: command,
                        sequence_id: this.sequenceId,
                        request_method: this.requestMethod,
                        request_body: this.requestBody,
                        request_bodytype: this.requestBodyType,
                        request_type: this.protocolType,
                        n: parseInt(this.totalRequests) || 0,
                        c: parseInt(this.concurrentConnections) || 1,
                        duration: parseInt(this.testDuration) * 1000000 || 1000 * 1000000,
                        timeout: parseInt(this.requestTimeout) * 1000000 || 3000 * 1000000,
                        qps: parseInt(this.qpsLimit) || 0,
                        disable_compression: this.disableCompression || this.disableCompression === "true",
                        disable_keepalives: this.disableKeepalives || this.disableKeepalives === "true",
                        auth_username: this.authUsername,
                        auth_password: this.authPassword,
                        url: this.requestUrl,
                        from: 'browser',
                    };
                },
                
                // Get Worker API address
                getWorkerApiEndpoint() {
                    return this.workerApiEndpoint.length > 0 ? this.workerApiEndpoint : DEFAULT_API_PATH;
                },
                
                initCharts() {
                    const init = (id) => {
                        const el = document.getElementById(id);
                        if (!el) return null;
                        try {
                            return echarts.init(el, 'dark', { renderer: 'canvas', useDirtyRect: false });
                        } catch (e) {
                            console.error('Failed to init chart:', id, e);
                            return null;
                        }
                    };
                    this.charts = {
                        perf: init('chart-container'),
                        lat: init('latency-chart'),
                        err: init('error-chart')
                    };
                    this.renderPerfChart([], []);
                },

                renderPerfChart(times, qps, status = {}) {
                    if (!this.charts.perf) return;
                    const series = [{ name: "qps", data: qps, type: 'line', smooth: true }];
                    const legend = ['qps'];
                    Object.keys(status).forEach(code => {
                        series.push({ name: code, data: status[code], type: 'line', smooth: true });
                        legend.push(code);
                    });
                    this.charts.perf.setOption({
                        legend: { data: legend },
                        tooltip: { trigger: 'axis', axisPointer: { type: 'cross' } },
                        xAxis: { type: 'category', data: times },
                        yAxis: { type: 'value' },
                        series
                    });
                },

                renderLatChart(lats) {
                    if (!this.charts.lat || !lats) return;
                    const entries = Object.entries(lats).map(([k, v]) => ({ val: parseInt(k)/1e6, count: v }));
                    if (!entries.length) return;

                    const min = Math.min(...entries.map(e => e.val));
                    const max = Math.max(...entries.map(e => e.val));
                    const buckets = 20;
                    const step = (max - min) / buckets || 1;
                    
                    const data = new Array(buckets).fill(0);
                    const cats = new Array(buckets).fill(0).map((_, i) => `${(min + i*step).toFixed(1)}-${(min + (i+1)*step).toFixed(1)}ms`);
                    
                    entries.forEach(e => {
                        let idx = Math.floor((e.val - min) / step);
                        if (idx >= buckets) idx = buckets - 1;
                        data[idx] += e.count;
                    });

                    this.charts.lat.setOption({
                        tooltip: { trigger: 'axis', axisPointer: { type: 'shadow' } },
                        grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                        xAxis: { type: 'category', data: cats, axisLabel: { interval: 'auto', rotate: 30 } },
                        yAxis: { type: 'value' },
                        series: [{ name: 'Count', type: 'bar', data, itemStyle: { color: '#667eea' } }]
                    });
                },

                renderErrChart(dist) {
                    if (!this.charts.err || !dist) return;
                    const data = Object.entries(dist).map(([name, value]) => ({ value, name }));
                    this.charts.err.setOption({
                        tooltip: { trigger: 'item' },
                        legend: { top: '5%', left: 'center' },
                        series: [{
                            name: 'Errors', type: 'pie', radius: ['40%', '70%'],
                            avoidLabelOverlap: false,
                            itemStyle: { borderRadius: 10, borderColor: '#fff', borderWidth: 2 },
                            label: { show: false, position: 'center' },
                            emphasis: { label: { show: true, fontSize: '14', fontWeight: 'bold' } },
                            data
                        }]
                    });
                },

                setupMetricsMonitoring(requestData, apiEndpoint) {
                    this.monitor = { timeLabels: [], qpsData: [], total: 0, statusCodes: {}, prevStatusCounts: {} };
                    const interval = parseInt(this.metricsInterval) || DEFAULT_METRICS_INTERVAL;
                    let errTimes = 0;

                    this.isRunning = true;
                    this.metricsTimer = setInterval(() => {
                        fetch(apiEndpoint, {
                            method: 'POST',
                            headers: CONTENT_TYPE_JSON,
                            body: JSON.stringify({ ...requestData, cmd: API_COMMANDS.GET_METRICS })
                        })
                        .then(r => r.json())
                        .then(data => {
                            if (data.err_code !== 0) {
                                if (++errTimes > 2) {
                                    this.stopTest();
                                    this.showMessage(data.err_msg, 'error', 5000);
                                }
                                return;
                            }
                            errTimes = 0;
                            this.processMetricsData(data, interval);
                        })
                        .catch(e => console.error("Metrics fetch failed:", e));
                    }, interval);
                },

                processMetricsData(data, interval) {
                    if (!data) return;
                    if (!this.hasData) {
                        this.hasData = true;
                        this.$nextTick(() => {
                            Object.values(this.charts).forEach(c => c && c.resize());
                        });
                    }

                    console.log("processMetricsData last metrics data:", data);
                    if (data.is_last) {
                        this.stopTest();
                        return;
                    }

                    this.stats = {
                        average: formatDuration(data.average),
                        rps: data.rps || 0,
                        fastest: formatDuration(data.fastest),
                        slowest: formatDuration(data.slowest),
                        errTotal: data.err_total || 0
                    };
                    this.renderLatChart(data.lats);
                    this.renderErrChart(data.error_dist);

                    if (data.lats_total && (data.lats_total - this.monitor.total) >= 0) {
                        this.monitor.timeLabels.push(new Date().format(TIME_FORMAT));
                        const currentQps = (data.lats_total - this.monitor.total) * 1000 / interval;
                        this.monitor.qpsData.push(currentQps);
                        this.monitor.total = data.lats_total;

                        if (data.status_code_dist) {
                            for (let code in data.status_code_dist) {
                                if (!this.monitor.statusCodes[code]) this.monitor.statusCodes[code] = [];
                                const count = data.status_code_dist[code];
                                const prev = this.monitor.prevStatusCounts[code] || 0;
                                this.monitor.statusCodes[code].push((count - prev) * 1000 / interval);
                                this.monitor.prevStatusCounts[code] = count;
                            }
                        }
                        this.renderPerfChart(this.monitor.timeLabels, this.monitor.qpsData, this.monitor.statusCodes);
                    }
                },
                
                stopTest() {
                    this.showMessage('stop');
                    this.isRunning = false;
                    clearInterval(this.metricsTimer);
                    this.metricsTimer = undefined;
                    
                    fetch(this.getWorkerApiEndpoint(), {
                        method: 'POST',
                        headers: CONTENT_TYPE_JSON,
                        body: JSON.stringify(this.buildRequestData(API_COMMANDS.STOP))
                    }).catch(e => console.error(e));
                }
            },
            created() {
                // Load saved language preference
                const savedLanguage = localStorage.getItem('preferred-language');
                if (savedLanguage && translations[savedLanguage]) {
                    this.currentLanguage = savedLanguage;
                }
            },
            mounted() {
                this.$nextTick(() => {
                    this.initCharts();
                    this.updateStaticTexts();
                    window.addEventListener('resize', debounce(() => {
                        Object.values(this.charts).forEach(c => c && c.resize());
                    }, 250));
                });
                document.documentElement.setAttribute('lang', this.currentLanguage);
            }
        });
    </script>
</body>
</html>